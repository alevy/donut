---
layout: default
title: Chord Implementation
permalink: /chord_implementation.html
---

h3. Introduction

Chord is an overlay network that maps logical addresses to physical nodes in a Peer-to-Peer system. Chord associates a ranges of keys with a particular node using a variant of consistent hashing. While traditional consistent hashing schemes require nodes to maintain state of the the system as a whole, Chord only requires that nodes know of a fixed number of "finger" nodes, allowing both massive scalability while maintaining efficient lookup time (O(log n)).

h3. Terms

h4. Chord

Chord works by arranging keys in a ring, such that when we reach the highest value in the key-space, the following key is zero. Nodes take on a particular key in this ring.

h4. Successor

Node <em>n</em> is called the successor of a key <em>k</em> if and only if <em>n</em> is the closest node after or equal to <em>k</em> on the ring.

h4. Predecessor

Node <em>n</em> is called the predecessor of a key <em>k</em> if and only <em>n</em> is the closest node before <em>k</em> in the ring.

h4. Finger

Nodes maintain a set of other nodes, called <em>fingers</em>, which refer to other points on the ring. The first <em>finger</em> of node <em>n</em> is always the successor of  <em>n</em>.

h4. Variables

|_. Variable |_. Definition |
| <em>K</em> | the total number of possible keys |
| <em>k</em> | a particular key in the key-space |
| <em>m</em> | log(<em>K</em>) |
| <em>N</em> | total number of nodes currently in the ring |
| <em>n</em> | a particular node |
| <em>r</em> | number of successors to keep in the successor list |

h3. Basic Design

A node <em>n</em> with key <em>k</em> stores a finger table containing the successors of the keys <em>k</em> + 2<sup>0</sup>, <em>k</em> + 2<sup>1</sup>, <em>k</em> + 2<sup>2</sup>,  ..., <em>k</em> + 2<sup><em>m</em></sup>. (Note: it may be the case that one node in two different finger entries). Given this distribution of fingers, the number of lookup  of any key's successor, as well as the number of messages to achieve the same, is O(log(<em>N</em>)).

Chord's lookup protocol is defined by the <em>findSuccessor</em> procedure. If node <em>n</em> realizes it is the predecessor of requested key <em>k</em>, <em>n</em>.<em>successor</em> is returned. Otherwise, the node finds the closest predecessor of <em>k</em> by searching <em>fingers</em> and invoking <em>findSuccessor</em> on the closest preceding node.

Donut's <em>findSuccessor</em> is recursive, meaning each node in the call tree blocks until a result is found. It is also possible to do this asynchronously, where the predeccessor of the key returns its successor directly to the client. Donut is particularly attune to this optimization since the clients are "request servers":RequestServer still internal to the system. However, network hops are not a primary performance bottleneck, so this optimization has not been implemented. 

h3. Joins

Nodes joining a chord ring must bootstrap using an existing node in the circle. To join existing known node <em>n</em>, joining node <em>n'</em> invokes <em>n.findSuccessor(n')</em>. Once <em>n'</em> finds its successor, <em>n"</em>, <em>n'</em> notifies <em>n"</em> which instructs <em>n"</em> to set its predecessor to <em>n'</em>. This is done in the <em>stabilize</em> routine. The joined is complete once the node immediately preceding <em>n'</em> recognizes that it is the predecessor of <em>n'</em>.

h3. Stabilize and Notify, Fix Fingers and Check Predecessor

With joining and leaving nodes, finger table entries, successors and predecessors must be periodically updated for all nodes. These operations are done at scheduled intervals spanning three procedures: <em>fixFingers</em>, <em>stabilize</em>, and <em>checkPredecessor</em>.

<em>stabilize</em> verifies a node's immediate successor and then notifies that successor to set its predecessor correctly. <em>stabilize</em> first queries its successor for its predecessor. If the successor has a predecessor between the two nodes, the node corrects who its successor is. This can occur when a new node joins the ring and its key lies between the stabilizing node and it's immediate successor.

<em>fixFingers</em> sequentially updates the finger table by invoking <em>findSuccessor</em>. Specifically, to update the <em>i<sup>th</sup></em> entry in the finger table, <em>findSuccessor</em> is called on the key <em>k</em> + 2<sup><em>i</em></sup>, where <em>k</em> is the current node's key.

<em>checkPredecessor</em> ensures that a node's predecessor is alive and well. A node periodically pings its predecessor. If the node does not respond, it is assumed dead and the node sets itself as the predecessor, awaiting notification from its new predecessor.

h3. Leaves and Successor Lists

As nodes leave the ring, usually due to system crashes or network errors, the ring stabilizes itself through <em>fixFingers</em>, <em>stabilize</em> and <em>checkPredecessor</em>. Between these three functions the predecessor gets set by <em>notify</em>, invalidated by <em>checkPredecessor</em>, fingers get updated by <em>fixFingers</em>, and the successor gets updated by <em>stabilize</em>. However, when a node's successor fails it must be invalidated and set to a new successor in order for the ring to be correct. Unlike a node's predecessor, a node will not be notified of a new, valid successor. For added robustness, a node keeps a list of <em>r</em> successors from which to remove the failed, old, successor and immediately update to the next successor. More formally, a successor list is the set of <em>r</em> successors to a node. The successor list is populated by the <em>notify</em> response from a node to its predecessor.

By using a successor list to handle node leaves, Donut can ensure the overlay network is resilient from up to <em>r</em> - 1 concurrent node failures within a defined interval.

